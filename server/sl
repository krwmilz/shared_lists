#!/usr/bin/perl -I.
use warnings;
use strict;

use BSD::arc4random qw(arc4random_bytes arc4random_stir);
use Digest::SHA qw(sha256_base64);
use File::Temp;
use Getopt::Std;
use IO::Socket::SSL;
use IO::Socket::UNIX;
use JSON::XS;
use Scalar::Util qw(looks_like_number);
use Try::Tiny;

# Our own modules
use logger;
use database;

require "msgs.pl";
our (%msg_num, @msg_str, @msg_func, $protocol_ver);

my %args;
getopts("p:t", \%args);

# This is used by the parent to create the database if it doesn't already
# exist, and then each child connects to this db to do queries
my $db_file = "db";
$db_file = File::Temp->new(SUFFIX => '.db', EXLOCK => 0) if ($args{t});

my $log = logger->new();
$log->print_bare("using database '$db_file'\n");

my $db = database->new($db_file);
$db->create_tables();

# Create master listening socket, by default on port 5437. All connection
# requests are served from this socket. Don't make this an SSL listening socket
# as the IO::Socket::SSL man page warns about potential blocks that can happen
# during an SSL handshake (which would be bad).
#
# So create the socket as plain TCP, accept plain TCP and then start SSL on the
# client socket.
my $server_socket = new IO::Socket::INET (
	LocalPort => $args{p} || '5437',
	Proto => 'tcp',
	Listen => 1,
	ReuseAddr => 1,
);
die "Could not create socket: $!\n" unless($server_socket);

my ($addr, $port) = ($server_socket->sockhost(), $server_socket->sockport());
$log->print_bare("accepting connections on $addr:$port (pid = '$$')\n");

# Children who have exited will do not have to be waited on with this
$SIG{CHLD} = 'IGNORE';

# Accept new plain TCP connections and handle them in separate processes
while (my $client_socket = $server_socket->accept()) {

	# Create a child process to handle this client
	my $pid = fork();
	if (!defined $pid) {
		die "error: can't fork: $!\n";
	} elsif ($pid) {
		# In parent: close our copy of the client socket and listen again
		close $client_socket;
		next;
	}

	close $server_socket;
	# Stir the random pool after fork() just in case
	arc4random_stir();

	$log->set_peer_host_port($client_socket);
	$log->print("new connection (pid = '$$')\n");

	# Upgrade plain TCP connection to SSL
	my $ret = IO::Socket::SSL->start_SSL($client_socket,
		SSL_server => 1,
		SSL_cert_file => 'certs/cert_chain.pem',
		SSL_key_file => 'certs/privkey.pem'
	);
	unless ($ret) {
		$log->print("error: $SSL_ERROR\n");
		exit 0;
	}

	my $ssl_ver = $client_socket->get_sslversion();
	my $ssl_cipher = $client_socket->get_cipher();
	$log->print("ssl ok, ver = '$ssl_ver' cipher = '$ssl_cipher'\n");

	my $db = database->new($db_file);
	$db->prepare_stmt_handles();

	handle_message($client_socket, $db) while (1);
}

sub handle_message {
	my ($client_socket, $db) = @_;

	# Make sure this gets reset
	undef $@;

	# Wait for an entire message to be received
	my ($ver, $msg_type, $request) = recv_msg($client_socket);

	$db->{dbh}->begin_work;

	# Every message type except 'device_add' needs to include 'device_id' in
	# the request. Check that here.
	my $device = undef;
	if ($msg_type != $msg_num{device_add}) {
		(my $err, $device) = get_device($db, $request->{device_id});

		if ($err) {
			send_msg($client_socket, $ver, $msg_type, make_error($err));
			$db->{dbh}->commit;
			return;
		}
	}

	# Call appropriate message handler. Each handler returns both data that
	# should be sent back over the main socket and notification data that
	# gets sent over vendor specific API.
	my ($response, $notify) = $msg_func[$msg_type]->($db, $request->{data}, $device);

	$db->{dbh}->commit;
	if ($@) {
		$log->print("db transaction aborted: $@\n");

		# now rollback to undo the incomplete changes but do it in an
		# eval{} as it may also fail
		eval { $db->{dbh}->rollback };

		$response->{status} = 'err';
		$response->{reason} = 'database transaction aborted';

		send_msg($client_socket, $ver, $msg_type, $response);
		return;
	}

	# Respond to client over the main socket
	send_msg($client_socket, $ver, $msg_type, $response);

	# Some messages don't send notifications
	return if (! defined $notify);

	# Don't send notifications when there was en error
	return if ($response->{status} eq 'err');

	# Encode the notification message and find its size
	my $msg = encode_json($notify);
	my $msg_len = length($msg);

	# Send to notification daemons
	send_unix("../apnd.socket", $msg, $msg_len) unless ($args{t});
	send_unix("../gcmd.socket", $msg, $msg_len) unless ($args{t});
	send_unix("../testd.socket", $msg, $msg_len) if ($args{t});
}

# Takes a request and verifies device_id is present and valid
sub get_device {
	my ($db, $device_id) = @_;

	unless (defined $device_id) {
		$log->print("bad request, missing key 'device_id'\n");
		return ("a missing message argument was required");
	}

	unless ($device_id && $device_id =~ m/^[a-zA-Z0-9+\/=]+$/) {
		$log->print("bad device id\n");
		return ('the client sent a device id that was not base64');
	}

	$db->{select_device_id}->execute($device_id);
	if (my ($num, $id, $phnum) = $db->{select_device_id}->fetchrow_array()) {
		my $device = {
			num => $num,
			fp => fingerprint($id),
			phnum => $phnum,
			id => $id
		};
		return (undef, $device);
	}

	$log->print("unknown device '$device_id'\n");
	return ('the client sent an unknown device id');
}

# Connect to a UNIX file system socket and send a JSON encoded message
# Returns nothing.
sub send_unix {
	my ($socket_path, $msg, $msg_len) = @_;

	# Every time this function is called we create a new connection to the
	# socket, send our data and then disconnect
	my $socket = IO::Socket::UNIX->new(
		Type => SOCK_STREAM(),
		Peer => $socket_path
	);
	unless ($socket) {
		$log->print("$socket_path: connect failed: $!\n");
		return;
	}

	# This is the same function we use for TCP data sending
	send_all($socket, $msg, $msg_len);

	close($socket);
}

# Receive an entire message, header + payload. Validate version, message type,
# and payload size from header. Then read the payload and make sure it's valid
# JSON, and that the JSON root was a dictionary.
# Returns a ($version, $msg_type, $payload) list. Exits on error.
sub recv_msg {
	my ($sock) = @_;

	# First read the fixed size 6 byte header
	my $header = read_all($sock, 6);
	my ($version, $msg_type, $payload_size) = unpack("nnn", $header);

	if ($version != 0) {
		$log->print("error: unsupported protocol version $version\n");
		exit 0;
	}

	if ($msg_type >= @msg_str) {
		$log->print("error: unknown message type $msg_type\n");
		exit 0;
	}
	$log->set_msg($msg_str[$msg_type]);

	# Server requests are limited to 4KB size, a 0 byte payload will not be
	# valid JSON so reject that here
	if ($payload_size > 4096 || $payload_size == 0) {
		$log->print("error: $payload_size byte payload invalid\n");
		exit 0;
	}

	# Now that we know the size of the message we can try and read the
	# entire thing exactly
	my $payload = read_all($sock, $payload_size);

	try {
		my $request = decode_json($payload);

		if (ref($request) ne "HASH") {
			$log->print("error: json payload didn't have dictionary root\n");
			exit 0;
		}
		return ($version, $msg_type, $request);
	} catch {
		$log->print("error: payload wasn't json\n");
		exit 0;
	}
}

# Read an exact amount of bytes from a socket.
# Returns the data read from the socket, exits on error.
sub read_all {
	my ($sock, $bytes_total) = @_;

	my $data;
	my $bytes_read = 0;
	while ($bytes_total > 0) {
		my $read = $sock->sysread($data, $bytes_total, $bytes_read);

		if (!defined $read) {
			$log->print("error: read failed: $!\n");
			exit 0;
		} elsif ($read == 0) {
			$log->print("disconnected!\n");
			exit 0;
		}

		$bytes_total -= $read;
		$bytes_read += $read;
	}

	return $data;
}

# Send an entire message (header + payload). Creates binary header by appending
# version, message type, and payload size. Then it appends the payload which is
# an encoded JSON string. Note we can't send native UTF-8 strings, they must be
# encoded and then decoded on the other (client) side.
# Returns number of bytes sent.
sub send_msg {
	my ($sock, $ver, $msg_type, $response) = @_;

	# $payload is now a single JSON string that has no characters whose
	# value is > 255
	my $payload = encode_json($response);

	my $header_len = 6;
	my $payload_len = length($payload);

	if ($payload_len > 65535) {
		# Don't send the response that was too large, but do send back a
		# quick message saying the response was too large
		my $err = make_error("response too large");
		# If the new error we pass here is greater than the maximum
		# payload length this will infinitely recurse.
		return send_msg($sock, $ver, $msg_type, $err);
	}

	send_all($sock, pack("nnn", $ver, $msg_type, $payload_len), $header_len);
	send_all($sock, $payload, $payload_len);

	# Clear logging prefix as late as possible so send errors above will
	# include the message type in them
	$log->set_msg('');
	return $header_len + $payload_len;
}

# Send an exact amount of data over $socket. SSL can only send max 16KB per
# frame so we need to loop to make sure everything gets sent.
# Returns the number of bytes written, exits on write failure.
sub send_all {
	my ($socket, $data, $bytes_total) = @_;

	my $bytes_written = 0;
	while ($bytes_total) {
		my $wrote = $socket->syswrite($data, $bytes_total, $bytes_written);

		unless (defined $wrote) {
			$log->print("error: write failed: $!\n");
			exit 0;
		}

		$bytes_total -= $wrote;
		$bytes_written += $wrote;
	}

	return $bytes_written;
}

# 'device_add' message handler. Validates incoming phone number, makes sure this
# phone number has not registered already, creates new device_id's.
# Does not return any push notifications because this device has no friends yet.
sub msg_device_add {
	my ($db, $request) = @_;

	# XXX: check that these exists first
	my $ph_num = $request->{'phone_number'};
	my $os = $request->{'os'};

	unless (looks_like_number($ph_num)) {
		$log->print("phone number invalid\n");
		return make_error("the sent phone number is not a number");
	}

	$db->{ph_num_exists}->execute($ph_num);
	if ($db->{ph_num_exists}->fetchrow_array()) {
		$log->print("phone number '$ph_num' already exists\n");
		return make_error("the sent phone number already exists");
	}
	# Only accept a white list of operating systems
	if ($os ne 'unix' && $os ne 'android' && $os ne 'ios') {
		$log->print("unknown operating system '$os'\n");
		return make_error("operating system not supported");
	}

	# Create new 256 bit random hashed string that we use as the unique
	# device id
	my $device_id = sha256_base64(arc4random_bytes(32));
	my $fp = fingerprint($device_id);

	# Check the database to make sure this isn't duplicate
	$db->{select_device_id}->execute($device_id);
	if ($db->{select_device_id}->fetchrow_array()) {
		$log->print("id generation collision for '$device_id'\n");
		return make_error("device id collision, please try again");
	}

	$db->{new_device}->execute($device_id, $ph_num, $os, undef, time, time);
	$log->print("success, '$ph_num':'$fp' os '$os'\n");

	return (make_ok( { data => $device_id } ), undef);
}

# 'device_update' message handler. Takes a device_id and a token and updates the
# devices table with the new token. Used so that the notification infrastructure
# knows about the latest token a device has.
# Returns with an ok message.
sub msg_device_update {
	my ($db, $request, $dev) = @_;

	my $hex_token = $request->{pushtoken_hex};
	$db->{update_device}->execute($hex_token, $dev->{num});
	# $log->print("push token = '$hex_token'\n");

	return make_ok( { data => {} });
}

# Takes a device_id and a list structure and records this list in the database.
# Also prepares an friend_added_list notification that should be sent to all my
# mutual friends.
sub msg_list_add {
	my ($db, $list, $dev) = @_;

	# XXX: check that $list contains the necessary keys!

	$log->print("device '$dev->{fp}'\n");
	$log->print("new list name '$list->{name}'\n");

	my $now = time;
	# Create new list, use null for primary key so the new row automatically
	# gets the lowest numbered integer that isn't used
	$db->{new_list}->execute($list->{name}, $list->{date}, $now, $now);
	my $list_num = $db->{dbh}->last_insert_id("", "", "", "");

	# Assign first reference count to the new list: the lists creator
	$db->{new_list_member}->execute($list_num, $dev->{num}, $now);

	# Send back a full list structure. Be extra careful about types here as
	# this is serialized by encode_json and types in Perl can be... tricky.
	my $resp_list = {
		num => $list_num,
		name => $list->{name},
		date => $list->{date},
		items_complete => 0,
		items_total => 0,
		members => [ $dev->{phnum} ],
		num_members => 1
	};
	my $response = make_ok( { data => $resp_list } );

	$log->print("new list number is '$list_num'\n");

	# For push notifications a list add on your part means all your friends
	# gain a list in their other lists section. Create the same response
	# that lists_get_other gives back for the notify payload
	$db->{mutual_friend_notify_select}->execute($dev->{num});
	my $notify->{devices} = $db->{mutual_friend_notify_select}->fetchall_arrayref();

	# Prepare a smaller list structure that will be sent to every device
	# selected above. Their client shows your new lists in their other lists
	# section, which doesn't need a lot of information.
	$notify->{msg_type} = 'friend_added_list';
	$notify->{data} = {
		num => $resp_list->{num},
		name => $list->{name},
		members => [ $dev->{phnum} ],
		num_members => 1
	};

	return ($response, $notify);
}

sub msg_list_update {
	my ($db, $list, $dev) = @_;

	my ($err) = list_number_valid($db, $list->{num});
	return make_error($err) if ($err);

	# Check that the device is in the list it wants to update
	$db->{check_list_member}->execute($list->{num}, $dev->{num});
	unless ($db->{check_list_member}->fetchrow_array()) {
		$log->print("device '$dev->{fp}' not in list '$list->{num}'\n");
		return make_error("client tried to update a list it was not in");
	}

	# Notify all of my mutual friends that my list changed
	$db->{mutual_friend_notify_select}->execute($dev->{num});
	my $mutual_friends = $db->{mutual_friend_notify_select}->fetchall_arrayref();

	# Notify all of the other list members that this list changed
	$db->{select_list_members}->execute($list->{num}, $dev->{num});
	my $list_members = $db->{select_list_members}->fetchall_arrayref();

	my $notify;
	$notify->{devices} = [@{ $mutual_friends }, @{ $list_members }];

	$notify->{msg_type} = 'updated_list';
	$notify->{data} = {
		num => $list->{num},
		name => $list->{name},
		date => $list->{date}
	};
	# print Dumper($notify);

	# Update list row, note that some values here can be optional
	$db->{update_list}->execute($list->{name}, $list->{date}, time, $list->{num});
	$log->print("num  = '$list->{num}'\n");
	$log->print("name = '$list->{name}'\n") if (exists $list->{name});
	$log->print("date = $list->{date}\n") if (exists $list->{date});

	return (make_ok( { data => {} } ), $notify);
}

sub msg_list_item_add {
    my ($db, $request, $device) = @_;

    return make_error("unimplemented");

    # my ($list_id, $position, $text) = split ("\0", $msg);
    
    # print "info: $addr: list $list_id\n";
    # print "info: $addr: position\n";
    # print "info: $addr: text $text\n";

    # check that list exists
    # check if item exists
    # check for "" owner on a stack
    # either create or add to unowned stack
    # owner will be emtpy
    # last_update 
}

sub msg_list_join {
    my ($db, $list_num, $dev) = @_;

    my ($list_err, $list_num_num, $list_name, $list_date) = list_number_valid($db, $list_num);
    return make_error($list_err) if ($list_err);

    my $time = time;
    $db->{check_list_member}->execute($list_num, $dev->{num});

    if (!$db->{check_list_member}->fetchrow_array()) {
        $db->{new_list_member}->execute($list_num, $dev->{num}, $time);
        $log->print("device '$dev->{fp}' has been added to list '$list_num'\n");
    } else {
        $log->print("tried to create a duplicate list member entry for device '$dev->{fp}' and list '$list_num'\n");
	return make_error("the device is already part of this list");
    }

    $db->{list_members_phnums}->execute($list_num);
    my $members_ref = $db->{list_members_phnums}->fetchall_arrayref();
    # $members_ref comes back as an array of arrays, flatten it
    my @members = map {@$_} @$members_ref;

    my $list = {
        num => $list_num_num,
        name => $list_name,
        date => $list_date,
        items_complete => 0,
        items_total => 0,
        members => \@members,
        num_members => scalar(@members)
    };

    $log->print("device '$dev->{fp}'\n");
    $log->print("list '$list_num'\n");

    return make_ok( { data => $list } );
}

sub msg_list_leave {
    my ($db, $list_num, $dev) = @_;

    my ($err) = list_number_valid($db, $list_num);
    return make_error($err) if ($err);

    $db->{check_list_member}->execute($list_num, $dev->{num});

    my $tmp_list_num = $list_num;
    if ($db->{check_list_member}->fetchrow_array()) {
        $db->{remove_list_member}->execute($list_num, $dev->{num});
        $log->print("device '$dev->{fp}' has been removed from list '$tmp_list_num'\n");
    } else {
        $log->print("tried to leave a list the user was not in for device '$dev->{fp}' and list '$tmp_list_num'\n");
        return make_error("the client was not a member of the list");
    }
    $db->{check_list_member}->finish();

    $db->{get_list_members}->execute($list_num);
    
    my $list_empty = 0;

    if (!$db->{get_list_members}->fetchrow_array()) {
        $log->print("list '$tmp_list_num' is empty... deleting\n");
        $db->{delete_list}->execute($list_num);
        $db->{delete_list_data}->execute($list_num);
        $list_empty = 1;
    }

    my $response = {
        list_num => $list_num,
        list_empty => $list_empty
    };

    $log->print("device '$dev->{fp}'\n");
    $log->print("list '$list_num'\n");

    return make_ok( { data => $response } );
}

sub msg_friend_add {
	my ($db, $friend_phnum, $dev) = @_;

	$log->print("'$dev->{fp}' adding '$friend_phnum'\n");

	unless (looks_like_number($friend_phnum)) {
		$log->print("bad friends number '$friend_phnum'\n");
		return make_error("friends phone number is not a valid phone number");
	}

	# Check if I'm adding myself as a friend
	if ($dev->{phnum} eq $friend_phnum) {
		$log->print("device '$dev->{fp}' tried adding itself\n");
		return make_error("device cannot add itself as a friend");
	}

	# Add a 1 way friendship for this person
	$db->{friends_insert}->execute($dev->{num}, $friend_phnum);

	# Check if the added friend has registered their phone number
	$db->{ph_num_exists}->execute($friend_phnum);
	if (my ($friend_num, $friend_devid) = $db->{ph_num_exists}->fetchrow_array()) {

		$log->print("added friend is a member\n");
		my $friend_fp = fingerprint($friend_devid);
		$log->print("friends device id is '$friend_fp'\n");

		# Check if my phone number is in their friends list
		$db->{friends_select}->execute($friend_num, $dev->{phnum});
		if ($db->{friends_select}->fetchrow_array()) {
			$log->print("found mutual friendship\n");

			# Adding both is not necessary but makes lookups easier
			$db->{mutual_friend_insert}->execute($dev->{num}, $friend_num);
			$db->{mutual_friend_insert}->execute($friend_num, $dev->{num});
		}
	}

	return make_ok( { data => $friend_phnum } );
}

sub msg_friend_delete {
	my ($db, $friend_phnum, $dev) = @_;

	unless (looks_like_number($friend_phnum)) {
		$log->print("bad friends number '$friend_phnum'\n");
		return make_error("friends phone number is not a valid phone number");
	}

	$db->{friends_select}->execute($dev->{num}, $friend_phnum);
	if ($db->{friends_select}->fetchrow_array()) {
		$log->print("removing '$friend_phnum' from friends list\n");
		$db->{friends_delete}->execute($dev->{num}, $friend_phnum);
	}
	else {
		$log->print("tried deleting friend '$friend_phnum' but they weren't a friend\n");
		return make_error("friend sent for deletion was not a friend");
	}

	# Check for and delete any mutual friend references
	$db->{ph_num_exists}->execute($friend_phnum);
	if (my ($friend_num) = $db->{ph_num_exists}->fetchrow_array()) {

		$log->print("also removing mutual friend relationship\n");
		$db->{mutual_friends_delete}->execute($dev->{num}, $friend_num);
		$db->{mutual_friends_delete}->execute($friend_num, $dev->{num});
	}

	return make_ok( { data => $friend_phnum } );
}

# Takes no arguments and finds all of the lists that the given device_id is in.
# Fills out complete list structures to send back.
# This message doesn't send any notifications.
sub msg_lists_get {
	my ($db, $request, $dev) = @_;

	$log->print("gathering lists for '$dev->{fp}'\n");

	my @lists;
	# Find all lists that this device number is a member of
	$db->{get_lists}->execute($dev->{num});
	while (my ($num, $name, $date) = $db->{get_lists}->fetchrow_array()) {

		# Get the phone numbers of all the list members
		$db->{list_members_phnums}->execute($num);
		my $members_ref = $db->{list_members_phnums}->fetchall_arrayref();

		# $members_ref comes back as an array of arrays, flatten it
		my @members = map {@$_} @$members_ref;

		my $num_members = scalar(@members);
		my $list = {
			num => $num,
			name => $name,
			date => $date,
			items_complete => 0,
			items_total => 0,
			members => \@members,
			num_members => $num_members
		};
		push @lists, $list;

		$log->print("found list '$num':'$name'\n");
		$log->print("list has $num_members members\n");
		$log->print("list has 0 items\n");
	}

	return make_ok( { data => \@lists} );
}

sub msg_lists_get_other {
	my ($db, $request, $dev) = @_;

	$log->print("gathering lists for '$dev->{fp}'\n");

	my %list_nums;
	# Find all mutual friends of this device
	$db->{mutual_friend_select}->execute($dev->{num});
	while (my @row = $db->{mutual_friend_select}->fetchrow_array()) {

		my ($friend_num, $friend_phnum) = @row;
		$log->print("found mutual friend '$friend_phnum'\n");

		# Find all of the lists my mutual friend is in (but not me)
		$db->{get_other_lists}->execute($friend_num, $dev->{num});
		while (my ($list_num) = $db->{get_other_lists}->fetchrow_array()) {

			my $lookup = $list_num;
			if (exists $list_nums{$lookup}) {
				# Append member and move on
				push @{ $list_nums{$lookup}->{members} }, $friend_phnum;
				$list_nums{$lookup}->{num_members} += 1;
				next
			}

			$db->{list_select}->execute($list_num);
			my (undef, $name) = $db->{list_select}->fetchrow_array();

			my $list = {
				num => $list_num,
				name => $name,
				members => [ $friend_phnum ],
				num_members => 1
			};
			$list_nums{$list_num} = $list;
			$log->print("found list '$name'\n");
		}
	}

	my @other_lists = values(%list_nums);
	return make_ok( { data => \@other_lists } );
}

sub msg_list_items_get {
	my ($db, $request, $dev) = @_;

	my $list_id = $request->{'list_num'};

	if (!$list_id) {
		$log->print("received null list id");
		return make_error("the sent list id was empty");
	}
	# unless ($dbh->selectrow_array($sth{check_list_member}, undef, $list_id, $device_id)) {
	# 	# XXX: table list_members list_id's should always exist in table lists
	# 	$log->print("list_items: $device_id not a member of $list_id\n");
	# 	return "err\0the sent device id is not a member of the list";
	# }
	$log->print("$dev->{id} request items for $list_id\n");

	$db->{get_list_items}->execute($list_id);

	my @items;
	while (my ($list_id, $pos, $name, $status, $owner, undef) =
		$db->{get_list_items}->fetchrow_array()) {
		$log->print("list item #$pos $name\n");

		push @items, "$pos:$name:$owner:$status";
	}

	my $out = join("\0", @items);
	return make_ok();
}

sub fingerprint {
	return substr shift, 0, 8;
}

sub list_number_valid {
	my ($db, $list_num) = @_;

	unless (defined $list_num) {
		$log->print("list number key not found\n");
		return ("the client did not send a list number");
	}

	unless (looks_like_number($list_num)) {
		$log->print("'$list_num' is not a number\n");
		return ("the client sent a list number that was not a number");
	}

	$db->{list_select}->execute($list_num);
	if (my @row = $db->{list_select}->fetchrow_array()) {
		return (undef, @row);
	}

	$log->print("unknown list number '$list_num'\n");
	return ("the client sent an unknown list number");
}

sub make_error {
	my ($reason) = @_;
	return { status => 'err', reason => $reason };
}

sub make_ok {
	my ($args) = @_;

	$args->{status} = 'ok';
	return $args;
}
