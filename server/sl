#!/usr/bin/perl -I.
use warnings;
use strict;

use BSD::arc4random qw(arc4random_bytes arc4random_stir);
use Digest::SHA qw(sha256_base64);
use DBI;
use File::Temp;
use Getopt::Std;
use IO::Socket::SSL;
use JSON::PP;
use Scalar::Util qw(looks_like_number);

require "msgs.pl";
our (%msg_num, @msg_str, @msg_func, $protocol_ver);

my %args;
getopts("p:t", \%args);

my $db_file = "db";
$db_file = File::Temp->new(SUFFIX => '.db', EXLOCK => 0) if ($args{t});

my $log = logger->new();
$log->print_bare("using database '$db_file'\n");

my $db = database->new();
$db->create_tables();

my $server_socket = new IO::Socket::INET (
	LocalPort => $args{p} || '5437',
	Proto => 'tcp',
	Listen => 1,
	ReuseAddr => 1,
);
die "Could not create socket: $!\n" unless($server_socket);

my ($addr, $port) = ($server_socket->sockhost(), $server_socket->sockport());
$log->print_bare("accepting connections on $addr:$port (pid = '$$')\n");

$SIG{CHLD} = 'IGNORE';
while (my $client_socket = $server_socket->accept()) {

	# Create a child process to handle this client
	my $pid = fork();
	if (!defined $pid) {
		die "error: can't fork: $!\n";
	} elsif ($pid) {
		# In parent: close our copy of the client socket and listen again
		close $client_socket;
		next;
	}

	# in child: on linux we must stir the random pool after fork()'s
	close $server_socket;
	arc4random_stir();
	$log->set_peer_host_port($client_socket);
	$log->print("new connection (pid = '$$')\n");

	# unconditionally upgrade connection to SSL
	my $ret = IO::Socket::SSL->start_SSL($client_socket,
		SSL_server => 1,
		SSL_cert_file => 'ssl/cert_chain.pem',
		SSL_key_file => 'ssl/privkey.pem'
	);
	unless ($ret) {
		$log->print("error: $SSL_ERROR\n");
		exit 0;
	}

	my $ssl_ver = $client_socket->get_sslversion();
	my $ssl_cipher = $client_socket->get_cipher();
	$log->print("ssl ok, ver = '$ssl_ver' cipher = '$ssl_cipher'\n");

	my $db = database->new();
	$db->prepare_stmt_handles();

	while (1) {
		my ($ver, $msg_type, $request) = recv_msg($client_socket);
		$log->set_msg($msg_str[$msg_type]);

		$db->{dbh}->begin_work;
		my $response = $msg_func[$msg_type]->($db, $request);
		$db->{dbh}->commit;

		if ($@) {
			# now rollback to undo the incomplete changes
			# but do it in an eval{} as it may also fail
			eval { $db->{dbh}->rollback };

			$log->print("db transaction aborted: $@\n");
			$response->{status} = 'err';
			$response->{reason} = "database transaction aborted";
		}

		$log->set_msg('');
		send_msg($client_socket, $ver, $msg_type, $response);
	}
}

sub recv_msg {
	my ($sock) = @_;

	my $header = read_all($sock, 6);
	my ($version, $msg_type, $payload_size) = unpack("nnn", $header);

	if ($version != 0) {
		$log->print("error: unsupported protocol version $version\n");
		exit 0;
	}
	elsif ($msg_type >= @msg_str) {
		$log->print("error: unknown message type $msg_type\n");
		exit 0;
	}
	elsif ($payload_size > 4096 || $payload_size == 0) {
		$log->print("error: $payload_size byte payload invalid\n");
		exit 0;
	}

	my $payload = read_all($sock, $payload_size);
	my $request = decode_json($payload);

	return ($version, $msg_type, $request);
}

sub read_all {
	my ($sock, $bytes_left) = @_;

	my $data;
	while ($bytes_left > 0) {
		my $bytes_read = $sock->sysread(my $tmp, $bytes_left);

		if (!defined $bytes_read) {
			$log->print("error: read failed: $!\n");
			exit 0;
		} elsif ($bytes_read == 0) {
			$log->print("disconnected!\n");
			exit 0;
		}

		$data .= $tmp;
		$bytes_left -= $bytes_read;
	}

	return $data;
}

sub send_msg {
	my ($sock, $ver, $msg_type, $response) = @_;

	my $payload = encode_json($response);

	my $header_len = 6;
	my $payload_len = length($payload);

	send_all($sock, pack("nnn", $ver, $msg_type, $payload_len), $header_len);
	send_all($sock, $payload, $payload_len);

	return $header_len + $payload_len;
}

sub send_all {
	my ($socket, $bytes, $bytes_total) = @_;

	my $bytes_written = $socket->syswrite($bytes);

	if (!defined $bytes_written) {
		$log->print("error: write failed: $!\n");
		exit 0;
	} elsif ($bytes_written != $bytes_total) {
		$log->print("error: wrote $bytes_written instead of $bytes_total bytes\n");
		exit 0;
	}

	return;
}

sub msg_device_add {
	my ($db, $request) = @_;

	my ($err, $ph_num, $os) = unpack_request($db, $request, 'phone_number', 'os');
	return make_error($err) if ($err);

	unless (looks_like_number($ph_num)) {
		$log->print("phone number '$ph_num' invalid\n");
		return make_error("the sent phone number is not a number");
	}

	$db->{ph_num_exists}->execute($ph_num);
	if ($db->{ph_num_exists}->fetchrow_array()) {
		$log->print("phone number '$ph_num' already exists\n");
		return make_error("the sent phone number already exists");
	}
	if ($os ne 'unix' && $os ne 'android' && $os ne 'ios') {
		$log->print("unknown operating system '$os'\n");
		return make_error("operating system not supported");
	}

	my $device_id = sha256_base64(arc4random_bytes(32));
	my $fp = fingerprint($device_id);

	# Check the database to make sure this isn't duplicate
	$db->{select_device_id}->execute($device_id);
	if ($db->{select_device_id}->fetchrow_array()) {
		$log->print("id generation collision for '$device_id'\n");
		return make_error("device id collision, please try again");
	}

	$db->{new_device}->execute($device_id, $ph_num, $os, undef, time, time);
	$log->print("success, '$ph_num':'$fp' os '$os'\n");

	return make_ok( { device_id => $device_id } );
}

sub msg_list_add {
	my ($db, $request) = @_;

	my ($err, $dev, $list) = unpack_request($db, $request, 'device_id', 'list');
	return make_error($err) if ($err);

	if ($list->{num} == 0) {
		# Sending a list number of 0 triggers new list mode
		$log->print("device '$dev->{fp}'\n");
		$log->print("new list name '$list->{name}'\n");

		my $now = time;
		$db->{new_list}->execute($list->{name}, $list->{date}, $now, $now);

		$list->{num} = $db->{dbh}->last_insert_id("", "", "", "");
		$log->print("new list number is '$list->{num}'\n");

		$db->{new_list_member}->execute($list->{num}, $dev->{num}, $now);

		# XXX: send push notifications to all my mutual friends to
		# update their 'other lists' section
	}
	else {
		# Otherwise we're in list update mode
		$err = list_number_valid($db, $list->{num});
		return make_error($err) if ($err);

		# Check that the device is in the list it wants to update
		$db->{check_list_member}->execute($list->{num}, $dev->{num});
		unless ($db->{check_list_member}->fetchrow_array()) {
			$log->print("device '$dev->{fp}' not in list '$list->{num}'\n");
			return make_error("client tried to update a list it was not in");
		}

		# Do the update
		$db->{update_list}->execute($list->{name}, $list->{date}, time, $list->{num});
		$log->print("updated list '$list->{num}'\n");

		# XXX: send push notifications to all my mutual friends to update their
		# 'other lists' section, also tell all list members to update their
		# 'lists' section
	}

	my $resp_list = {
		num => $list->{num},
		name => $list->{name},
		date => $list->{date},
		items_complete => 0,
		items_total => 0,
		members => [ $dev->{phnum} ],
		num_members => 1
	};
	return make_ok( { list => $resp_list } );
}

sub msg_list_item_add {
    my ($db, $request) = @_;

    my ($err, $device) = unpack_request($db, $request, 'device_id');
    return make_error($err) if ($err);

    return make_error("unimplemented");

    # my ($list_id, $position, $text) = split ("\0", $msg);
    
    # print "info: $addr: list $list_id\n";
    # print "info: $addr: position\n";
    # print "info: $addr: text $text\n";

    # check that list exists
    # check if item exists
    # check for "" owner on a stack
    # either create or add to unowned stack
    # owner will be emtpy
    # last_update 
}

sub msg_list_join {
    my ($db, $request) = @_;

    my ($err, $dev, $list_num) = unpack_request($db, $request, 'device_id', 'list_num');
    return make_error($err) if ($err);

    $err = list_number_valid($db, $list_num);
    return make_error($err) if ($err);

    $log->print("device '$dev->{fp}'\n");
    $log->print("list '$list_num'\n");
    
    my $time = time;
    $db->{check_list_member}->execute($list_num, $dev->{num});

    if (!$db->{check_list_member}->fetchrow_array()) {
        $db->{new_list_member}->execute($list_num, $dev->{num}, $time);
        $log->print("device '$dev->{fp}' has been added to list '$list_num'\n");
    } else {
        $log->print("tried to create a duplicate list member entry for device '$dev->{fp}' and list '$list_num'\n");
	return make_error("the device is already part of this list");
    }

    my $list = {
        num => $list_num,
        # XXX: we should return the following here too
        # name => $list_name,
        # date => $list_date,
        # items_complete => 0,
        # items_total => 0,
        # members => [ $phnum ],
        # num_members => 1
    };
    return make_ok( { list => $list } );
}

sub msg_list_leave {
    my ($db, $request) = @_;

    my ($err, $dev, $list_num) = unpack_request($db, $request, 'device_id', 'list_num');
    return make_error($err) if ($err);

    $err = list_number_valid($db, $list_num);
    return make_error($err) if ($err);

    $log->print("device '$dev->{fp}'\n");
    $log->print("list '$list_num'\n");

    $db->{check_list_member}->execute($list_num, $dev->{num});

    if ($db->{check_list_member}->fetchrow_array()) {
        $db->{remove_list_member}->execute($list_num, $dev->{num});
        $log->print("device '$dev->{fp}' has been removed from list '$list_num'\n");
    } else {
        $log->print("tried to leave a list the user was not in for device '$dev->{fp}' and list '$list_num'\n");
        return make_error("the client was not a member of the list");
    }
    $db->{check_list_member}->finish();

    $db->{get_list_members}->execute($list_num);
    
    my $list_empty = 0;

    if (!$db->{get_list_members}->fetchrow_array()) {
        $log->print("list '$list_num' is empty... deleting\n");
        $db->{delete_list}->execute($list_num);
        $db->{delete_list_data}->execute($list_num);
        $list_empty = 1;
    }

    my $response = {
        list_num => $list_num,
        list_empty => $list_empty
    };
    return make_ok($response);
}

sub msg_friend_add {
	my ($db, $request) = @_;

	my ($err, $dev, $friend_phnum) = unpack_request($db, $request, 'device_id', 'friend_phnum');
	return make_error($err) if ($err);

	$log->print("'$dev->{fp}' adding '$friend_phnum'\n");

	unless (looks_like_number($friend_phnum)) {
		$log->print("bad friends number '$friend_phnum'\n");
		return make_error("friends phone number is not a valid phone number");
	}

	# Check if I'm adding myself as a friend
	if ($dev->{phnum} eq $friend_phnum) {
		$log->print("device '$dev->{fp}' tried adding itself\n");
		return make_error("device cannot add itself as a friend");
	}

	# Add a 1 way friendship for this person
	$db->{friends_insert}->execute($dev->{num}, $friend_phnum);

	# Check if the added friend has registered their phone number
	$db->{ph_num_exists}->execute($friend_phnum);
	if (my ($friend_num, $friend_devid) = $db->{ph_num_exists}->fetchrow_array()) {

		$log->print("added friend is a member\n");
		my $friend_fp = fingerprint($friend_devid);
		$log->print("friends device id is '$friend_fp'\n");

		# Check if my phone number is in their friends list
		$db->{friends_select}->execute($friend_num, $dev->{phnum});
		if ($db->{friends_select}->fetchrow_array()) {
			$log->print("found mutual friendship\n");

			# Adding both is technically not necessary but makes
			# lookups easier
			$db->{mutual_friend_insert}->execute($dev->{num}, $friend_num);
			$db->{mutual_friend_insert}->execute($friend_num, $dev->{num});
		}
	}

	return make_ok( { friend_phnum => $friend_phnum } );
}

sub msg_friend_delete {
	my ($db, $request) = @_;

	my ($err, $dev, $friend_phnum) = unpack_request($db, $request, 'device_id', 'friend_phnum');
	return make_error($err) if ($err);

	unless (looks_like_number($friend_phnum)) {
		$log->print("bad friends number '$friend_phnum'\n");
		return make_error("friends phone number is not a valid phone number");
	}

	$db->{friends_select}->execute($dev->{num}, $friend_phnum);
	if ($db->{friends_select}->fetchrow_array()) {
		$log->print("removing '$friend_phnum' from friends list\n");
		$db->{friends_delete}->execute($dev->{num}, $friend_phnum);
	}
	else {
		$log->print("tried deleting friend '$friend_phnum' but they weren't a friend\n");
		return make_error("friend sent for deletion was not a friend");
	}

	# Check for and delete any mutual friend references
	$db->{ph_num_exists}->execute($friend_phnum);
	if (my ($friend_num) = $db->{ph_num_exists}->fetchrow_array()) {

		$log->print("also removing mutual friend relationship\n");
		$db->{mutual_friends_delete}->execute($dev->{num}, $friend_num);
		$db->{mutual_friends_delete}->execute($friend_num, $dev->{num});
	}

	return make_ok( { friend_phnum => $friend_phnum } );
}

sub msg_lists_get {
	my ($db, $request) = @_;

	my ($err, $dev) = unpack_request($db, $request, 'device_id');
	return make_error($err) if ($err);

	$log->print("gathering lists for '$dev->{fp}'\n");

	my @lists;
	$db->{get_lists}->execute($dev->{num});
	while (my ($list_num, $list_name) = $db->{get_lists}->fetchrow_array()) {

		$log->print("found list '$list_num':'$list_name'\n");

		# Find all members of this list
		my @members;
		$db->{get_list_members}->execute($list_num);
		while (my ($member_num) = $db->{get_list_members}->fetchrow_array()) {

			# Don't re look-up our own number
			if ($member_num eq $dev->{num}) {
				push @members, $dev->{phnum};
				next;
			}
			push @members, devnum_to_phnum($db, $member_num);
		}

		my $list = {
			num => $list_num,
			name => $list_name,
			date => 0,
			items_complete => 0,
			items_total => 0,
			members => \@members,
			num_members => scalar(@members)
		};
		push @lists, $list;

		$log->print("list has $list->{num_members} members\n");
		$log->print("list has $list->{items_total} items\n");
	}

	my $response = {
		lists => \@lists,
		num_lists => scalar(@lists)
	};
	return make_ok($response);
}

sub msg_lists_get_other {
	my ($db, $request) = @_;

	my ($err, $dev) = unpack_request($db, $request, 'device_id');
	return make_error($err) if ($err);

	$log->print("gathering lists for '$dev->{fp}'\n");

	# Get lists this device is already in, used for filtering later
	my @my_lists;
	$db->{get_lists}->execute($dev->{num});
	while (my ($list_num) = $db->{get_lists}->fetchrow_array()) {
		push @my_lists, $list_num;
	}

	my %list_nums;
	# Find all mutual friends of this device
	$db->{mutual_friend_select}->execute($dev->{num});
	while (my ($friend_num) = $db->{mutual_friend_select}->fetchrow_array()) {

		# We can't send device id's back to the client
		my $friend_phnum = devnum_to_phnum($db, $friend_num);
		$log->print("found mutual friend '$friend_phnum'\n");

		# Find all of the lists my mutual friend is in (but not me)
		$db->{get_lists}->execute($friend_num);
		while (my ($list_num, $name) = $db->{get_lists}->fetchrow_array()) {

			# Filter out lists my device is already in
			next if (grep {$_ eq $list_num} @my_lists);

			if (exists $list_nums{$list_num}) {
				# Append member and move on
				push @{ $list_nums{$list_num}->{members} }, $friend_phnum;
				$list_nums{$list_num}->{num_members} += 1;
				next
			}

			my $list = {
				num => $list_num,
				name => $name,
				members => [ $friend_phnum ],
				num_members => 1
			};
			$list_nums{$list_num} = $list;
			$log->print("found list '$name'\n");
		}
	}

	my @other_lists = values(%list_nums);
	my $response = {
		other_lists => \@other_lists,
		num_other_lists => scalar(@other_lists)
	};
	return make_ok($response);
}

sub msg_list_items_get {
	my ($db, $request) = @_;

	my ($err, $dev, $list_id) = unpack_request($db, $request, 'device_id', 'list_num');
	return make_error($err) if ($err);

	if (!$list_id) {
		$log->print("received null list id");
		return make_error("the sent list id was empty");
	}
	# unless ($dbh->selectrow_array($sth{check_list_member}, undef, $list_id, $device_id)) {
	# 	# XXX: table list_members list_id's should always exist in table lists
	# 	$log->print("list_items: $device_id not a member of $list_id\n");
	# 	return "err\0the sent device id is not a member of the list";
	# }
	$log->print("$dev->{id} request items for $list_id\n");

	$db->{get_list_items}->execute($list_id);

	my @items;
	while (my ($list_id, $pos, $name, $status, $owner, undef) =
		$db->{get_list_items}->fetchrow_array()) {
		$log->print("list item #$pos $name\n");

		push @items, "$pos:$name:$owner:$status";
	}

	my $out = join("\0", @items);
	return make_ok();
}

sub fingerprint {
	return substr shift, 0, 8;
}

sub devnum_to_phnum {
	my ($db, $dev_num) = @_;

	$db->{select_device_num}->execute($dev_num);
	my (undef, undef, $ph_num) = $db->{select_device_num}->fetchrow_array;

	return $ph_num;
}

sub list_number_valid {
	my ($db, $list_num) = @_;

	unless (looks_like_number($list_num)) {
		$log->print("'$list_num' is not a number\n");
		return "the client sent a list number that was not a number";
	}

	$db->{list_select}->execute($list_num);
	unless ($db->{list_select}->fetchrow_array()) {
		$log->print("unknown list number '$list_num'\n");
		return "the client sent an unknown list number";
	}

	return;
}

sub make_error {
	my ($reason) = @_;
	return { status => 'err', reason => $reason };
}

sub make_ok {
	my ($args) = @_;

	$args->{status} = 'ok';
	return $args;
}

sub unpack_request {
	# Function that gets values from a hash in a specified key order
	my ($db, $request, @expected_keys) = @_;

	my @values;
	for (@expected_keys) {
		# Check if the caller requested a key that was not provided
		if (! exists $request->{$_}) {
			$log->print("bad request, missing key '$_'\n");
			return ("a missing message argument was required");
		}

		if ($_ ne 'device_id') {
			push @values, $request->{$_};
			next;
		}

		# When callers request 'device_id' we check the id is valid here
		my ($err, $device) = device_id_valid($db, $request->{$_});
		return ($err) if ($err);

		push @values, $device;
	}
	return (undef, @values);
}

sub device_id_valid {
	my ($db, $device_id) = @_;

	unless ($device_id && $device_id =~ m/^[a-zA-Z0-9+\/=]+$/) {
		$log->print("bad device id\n");
		return ('the client sent a device id that was not base64');
	}

	$db->{select_device_id}->execute($device_id);
	if (my ($num, $id, $phnum) = $db->{select_device_id}->fetchrow_array()) {
		my $device = {
			num => $num,
			fp => fingerprint($id),
			phnum => $phnum,
			id => $id
		};
		return (undef, $device);
	}

	$log->print("unknown device '$device_id'\n");
	return ('the client sent an unknown device id');
}

package database;

sub new {
	my $class = shift;

	my $self = {};
	bless ($self, $class);

	$self->{dbh} = DBI->connect(
		"dbi:SQLite:dbname=$db_file",
		"", "",
		{
			RaiseError => 1,
			sqlite_unicode => 1,
		}
	) or die $DBI::errstr;

	$self->{dbh}->do("PRAGMA foreign_keys = ON");
	$self->{dbh}->{AutoCommit} = 1;

	return $self;
}

sub create_tables {
	my ($self) = @_;

	my $db_handle = $self->{dbh};
	$db_handle->begin_work;

	$db_handle->do(qq{
		create table if not exists lists (
		num integer primary key,
		name text not null,
		date int,
		created int not null,
		last_updated int not null)
	});

	$db_handle->do(qq{
		create table if not exists devices (
		num integer primary key,
		id text not null,
		phone_num text not null,
		os text,
		push_token text,
		seen_first int not null,
		seen_last int not null)
	});

	$db_handle->do(qq{
		create table if not exists friends (
		device integer not null,
		friend text not null,
		primary key(device, friend),
		foreign key(device) references devices(num))
	});

	$db_handle->do(qq{
		create table if not exists mutual_friends (
		device integer not null,
		mutual_friend integer not null,
		primary key(device, mutual_friend),
		foreign key(device) references devices(num),
		foreign key(mutual_friend) references devices(num))
	});

	$db_handle->do(qq{
		create table if not exists list_members (
		list integer,
		device integer,
		joined int not null,
		primary key(list, device),
		foreign key(list) references lists(num),
		foreign key(device) references devices(num))
	});

	$db_handle->do(qq{
		create table if not exists list_data (
		num integer primary key,
		list integer,
		name text,
		owner integer,
		status int not null default 0,
		quantity,
		created int not null,
		last_updated int not null,
		foreign key(list) references lists(num),
		foreign key(owner) references devices(num))
	});

	$db_handle->commit;
	$self->{dbh}->disconnect();
	$self->{dbh} = undef;
}

sub prepare_stmt_handles {
	my ($self) = @_;

	my $dbh = $self->{dbh};
	my $sql;

	# list table queries
	$sql = 'select * from lists where num = ?';
	$self->{list_select} = $dbh->prepare($sql);

	$sql = 'insert into lists (name, date, created, last_updated) values (?, ?, ?, ?)';
	$self->{new_list} = $dbh->prepare($sql);

	$sql = 'update lists set name = ?, date = ?, last_updated = ? where num = ?';
	$self->{update_list} = $dbh->prepare($sql);

	$sql = 'delete from lists where num = ?';
	$self->{delete_list} = $dbh->prepare($sql);

	# devices table queries
	$sql = 'insert into devices (id, phone_num, os, push_token, seen_first, seen_last) values (?, ?, ?, ?, ?, ?)';
	$self->{new_device} = $dbh->prepare($sql);

	$sql = 'select * from devices where phone_num = ?';
	$self->{ph_num_exists} = $dbh->prepare($sql);

	$sql = 'select * from devices where id = ?';
	$self->{select_device_id} = $dbh->prepare($sql);

	$sql = 'select * from devices where num = ?';
	$self->{select_device_num} = $dbh->prepare($sql);

	# friends table queries
	$sql = 'insert or replace into friends (device, friend) values (?, ?)';
	$self->{friends_insert} = $dbh->prepare($sql);

	$sql = 'select * from friends where device = ? and friend = ?';
	$self->{friends_select} = $dbh->prepare($sql);

	$sql = 'delete from friends where device = ? and friend = ?';
	$self->{friends_delete} = $dbh->prepare($sql);

	# mutual_friends table queries
	$sql = 'insert or replace into mutual_friends (device, mutual_friend) values (?, ?)';
	$self->{mutual_friend_insert} = $dbh->prepare($sql);

	$sql = 'select mutual_friend from mutual_friends where device = ?';
	$self->{mutual_friend_select} = $dbh->prepare($sql);

	$sql = 'delete from mutual_friends where device = ? and mutual_friend = ?';
	$self->{mutual_friends_delete} = $dbh->prepare($sql);

	# lists/list_members compound queries
	$sql = qq{select lists.num, lists.name from lists, list_members where
		lists.num = list_members.list and list_members.device = ?};
	$self->{get_lists} = $dbh->prepare($sql);

	# list_members table queries
	$sql = 'select device from list_members where list = ?';
	$self->{get_list_members} = $dbh->prepare($sql);

	$sql = 'insert into list_members (list, device, joined) values (?, ?, ?)';
	$self->{new_list_member} = $dbh->prepare($sql);

	$sql = 'delete from list_members where list = ? and device = ?';
	$self->{remove_list_member} = $dbh->prepare($sql);

	$sql = 'select device from list_members where list = ? and device = ?';
	$self->{check_list_member} = $dbh->prepare($sql);

	# list_data table queries
	$sql = 'delete from list_data where list = ?';
	$self->{delete_list_data} = $dbh->prepare($sql);

	$sql = 'select * from list_data where list = ?';
	$self->{get_list_items} = $dbh->prepare($sql);

	$sql = 'insert into list_data (list, name, quantity, status, owner, last_updated) values (?, ?, ?, ?, ?, ?)';
	$self->{new_list_item} = $dbh->prepare($sql);
}

package logger;
use POSIX;

sub new {
	my $class = shift;

	my $self = {};
	bless ($self, $class);

	$self->{addr} = '';
	$self->{port} = '';
	$self->{msg_type} = '';
	return $self;
}

sub set_peer_host_port {
	my ($self, $sock) = @_;
	($self->{addr}, $self->{port}) = ($sock->peerhost(), $sock->peerport());
}

sub set_msg {
	my ($self, $msg_type) = @_;

	if ($msg_type ne '') {
		$self->{msg_type} = "$msg_type: ";
	} else {
		$self->{msg_type} = '';
	}
}

sub print {
	my ($self, @args) = @_;

	my $ftime = strftime("%F %T", localtime);
	printf "%s %-15s %-5s> %s", $ftime, $self->{addr}, $self->{port}, $self->{msg_type};
	# we print potentially unsafe strings here, don't use printf
	print @args;
}

sub print_bare {
	my ($self, @args) = @_;

	my $ftime = strftime("%F %T", localtime);
	printf "%s> ", $ftime;
	printf @args;
}
